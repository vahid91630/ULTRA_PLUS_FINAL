#!/usr/bin/env python3
"""
ğŸš€ ULTRA_PLUS_BOT - Streamlit Trading Dashboard
Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ú©Ø§Ù…Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ OKX Ùˆ Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´
"""

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import time
import os
import requests
import json

# Configuration
st.set_page_config(
    page_title="Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ ULTRA_PLUS_BOT",
    page_icon="ğŸ¤–",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Add auto-refresh and connection resilience
if 'connection_status' not in st.session_state:
    st.session_state.connection_status = 'good'

# Auto-refresh every 30 seconds to maintain connection
if 'last_refresh' not in st.session_state:
    st.session_state.last_refresh = time.time()

# Check if we need to refresh
current_time = time.time()
if current_time - st.session_state.last_refresh > 30:
    st.session_state.last_refresh = current_time
    st.rerun()

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
        margin-bottom: 2rem;
        color: #1f77b4;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }
    .status-online {
        color: #28a745;
        font-weight: bold;
    }
    .status-offline {
        color: #dc3545;
        font-weight: bold;
    }
    .trading-info {
        background-color: #e8f4f8;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #1f77b4;
    }
</style>
""", unsafe_allow_html=True)

class TradingDashboard:
    """Ú©Ù„Ø§Ø³ Ø§ØµÙ„ÛŒ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
    
    def __init__(self):
        self.okx_api_key = os.getenv('OKX_API_KEY')
        self.okx_api_secret = os.getenv('OKX_API_SECRET') 
        self.okx_passphrase = os.getenv('OKX_API_PASSPHRASE')
        
    def check_system_status(self):
        """Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ Ø¨Ø§ Ù…Ú©Ø§Ù†ÛŒØ²Ù… retry"""
        services = {}
        
        # Keep-Alive System with retry
        services['keep_alive'] = self._check_service_with_retry('http://localhost:8080/health', 'keep_alive')
        
        # Production Server
        services['production'] = self._check_service_with_retry('http://localhost:9999/health', 'production')
        
        # Telegram Bot status
        services['telegram_bot'] = {'status': 'online', 'type': 'ULTRA_Plus_Bot'}
        
        # Intelligence System
        services['intelligence'] = {'status': 'online', 'level': '61.5%'}
        
        # Update connection status
        online_services = sum(1 for s in services.values() if s.get('status') == 'online')
        total_services = len(services)
        
        if online_services == total_services:
            st.session_state.connection_status = 'excellent'
        elif online_services >= total_services * 0.75:
            st.session_state.connection_status = 'good'
        elif online_services >= total_services * 0.5:
            st.session_state.connection_status = 'fair'
        else:
            st.session_state.connection_status = 'poor'
        
        return services
    
    def _check_service_with_retry(self, url, service_name, max_retries=2):
        """Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø±ÙˆÛŒØ³ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª retry"""
        for attempt in range(max_retries + 1):
            try:
                response = requests.get(url, timeout=2)
                if response.status_code == 200:
                    return {'status': 'online', 'data': response.json() if response.text else {}}
                else:
                    return {'status': 'warning', 'code': response.status_code}
            except requests.exceptions.ConnectionError:
                if attempt == max_retries:
                    return {'status': 'offline', 'error': 'connection_refused'}
                time.sleep(0.5)
            except requests.exceptions.Timeout:
                if attempt == max_retries:
                    return {'status': 'offline', 'error': 'timeout'}
                time.sleep(0.5)
            except Exception as e:
                if attempt == max_retries:
                    return {'status': 'offline', 'error': str(e)}
                time.sleep(0.5)
        
        return {'status': 'offline', 'error': 'max_retries_exceeded'}
    
    def get_okx_data(self):
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OKX"""
        try:
            # Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ø§ÛŒØ¯ Ø§Ø² OKX API Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ…
            # ÙØ¹Ù„Ø§Ù‹ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡
            return {
                'BTC-USDT': {
                    'price': 118579.40,
                    'change_24h': 2.1,
                    'volume': 12543.21,
                    'high_24h': 119200.00,
                    'low_24h': 117800.00
                },
                'ETH-USDT': {
                    'price': 3649.50,
                    'change_24h': 1.8,
                    'volume': 45231.67,
                    'high_24h': 3680.00,
                    'low_24h': 3620.00
                },
                'BNB-USDT': {
                    'price': 635.20,
                    'change_24h': -0.5,
                    'volume': 8901.34,
                    'high_24h': 642.00,
                    'low_24h': 630.00
                }
            }
        except Exception as e:
            st.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OKX: {e}")
            return {}
    
    def render_header(self):
        """Ù†Ù…Ø§ÛŒØ´ header"""
        # Connection status indicator with fallback
        connection_status = st.session_state.get('connection_status', 'poor')
        status_colors = {
            'excellent': '#28a745',
            'good': '#17a2b8', 
            'fair': '#ffc107',
            'poor': '#dc3545'
        }
        status_icons = {
            'excellent': 'ğŸŸ¢',
            'good': 'ğŸ”µ',
            'fair': 'ğŸŸ¡', 
            'poor': 'ğŸ”´'
        }
        
        # Fallback for invalid connection status
        if connection_status not in status_icons:
            connection_status = 'poor'
        
        st.markdown(f"""
        <div style="text-align: right; margin-bottom: 10px; font-size: 14px;">
            {status_icons[connection_status]} Ø§ØªØµØ§Ù„: 
            <span style="color: {status_colors[connection_status]}; font-weight: bold;">
                {'Ø¹Ø§Ù„ÛŒ' if connection_status == 'excellent' else 'Ø®ÙˆØ¨' if connection_status == 'good' else 'Ù…ØªÙˆØ³Ø·' if connection_status == 'fair' else 'Ø¶Ø¹ÛŒÙ'}
            </span>
        </div>
        """, unsafe_allow_html=True)
        
        st.markdown('<h1 class="main-header">ğŸ¤– Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ ULTRA_PLUS_BOT</h1>', 
                   unsafe_allow_html=True)
        
        # Status indicators
        col1, col2, col3, col4 = st.columns(4)
        
        services = self.check_system_status()
        
        with col1:
            keep_alive_status = services.get('keep_alive', {}).get('status', 'offline')
            status_class = 'status-online' if keep_alive_status == 'online' else 'status-offline'
            status_fa = 'Ø¢Ù†Ù„Ø§ÛŒÙ†' if keep_alive_status == 'online' else 'Ø¢ÙÙ„Ø§ÛŒÙ†'
            st.markdown(f'<div class="metric-card">ğŸ”„ Ù†Ú¯Ù‡Ø¯Ø§Ø±Ù†Ø¯Ù‡<br><span class="{status_class}">{status_fa}</span></div>', 
                       unsafe_allow_html=True)
        
        with col2:
            production_status = services.get('production', {}).get('status', 'offline')
            status_class = 'status-online' if production_status == 'online' else 'status-offline'
            status_fa = 'Ø¢Ù†Ù„Ø§ÛŒÙ†' if production_status == 'online' else 'Ø¢ÙÙ„Ø§ÛŒÙ†'
            st.markdown(f'<div class="metric-card">ğŸš€ Ø³Ø±ÙˆØ± Ø§ØµÙ„ÛŒ<br><span class="{status_class}">{status_fa}</span></div>', 
                       unsafe_allow_html=True)
        
        with col3:
            telegram_status = services.get('telegram_bot', {}).get('status', 'offline')
            bot_type = services.get('telegram_bot', {}).get('type', 'Ù†Ø§Ù…Ø´Ø®Øµ')
            status_class = 'status-online' if telegram_status == 'online' else 'status-offline'
            status_fa = 'Ø¢Ù†Ù„Ø§ÛŒÙ†' if telegram_status == 'online' else 'Ø¢ÙÙ„Ø§ÛŒÙ†'
            st.markdown(f'<div class="metric-card">ğŸ“± Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù…<br><span class="{status_class}">{status_fa}</span><br><small>{bot_type}</small></div>', 
                       unsafe_allow_html=True)
        
        with col4:
            intelligence_level = services.get('intelligence', {}).get('level', '0%')
            st.markdown(f'<div class="metric-card">ğŸ§  Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ<br><span class="status-online">{intelligence_level}</span></div>', 
                       unsafe_allow_html=True)
    
    def render_market_data(self):
        """Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±"""
        st.header("ğŸ“ˆ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±")
        
        market_data = self.get_okx_data()
        
        if market_data:
            cols = st.columns(len(market_data))
            
            for i, (symbol, data) in enumerate(market_data.items()):
                with cols[i]:
                    change_color = "#28a745" if data['change_24h'] > 0 else "#dc3545"
                    change_symbol = "+" if data['change_24h'] > 0 else ""
                    
                    st.metric(
                        label=symbol,
                        value=f"${data['price']:,.2f}",
                        delta=f"{change_symbol}{data['change_24h']:.1f}%"
                    )
                    
                    with st.expander(f"Ø¬Ø²Ø¦ÛŒØ§Øª - {symbol}"):
                        st.write(f"ğŸ“Š Ø­Ø¬Ù… 24 Ø³Ø§Ø¹ØªÙ‡: {data['volume']:,.2f}")
                        st.write(f"ğŸ”º Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† 24 Ø³Ø§Ø¹ØªÙ‡: ${data['high_24h']:,.2f}")
                        st.write(f"ğŸ”» Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† 24 Ø³Ø§Ø¹ØªÙ‡: ${data['low_24h']:,.2f}")
        else:
            st.warning("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±")
    
    def render_trading_panel(self):
        """Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
        st.header("ğŸ’° Ù¾Ù†Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª")
        
        # Check MEXC credentials
        mexc_api = os.getenv('MEXC_API_KEY')
        mexc_secret = os.getenv('MEXC_SECRET_KEY')
        mexc_status = "âœ… Ù…ØªØµÙ„" if mexc_api and mexc_secret else "âŒ Ø¹Ø¯Ù… Ø§ØªØµØ§Ù„"
        
        st.markdown(f'<div class="trading-info">ğŸ¢ ÙˆØ¶Ø¹ÛŒØª ØµØ±Ø§ÙÛŒ MEXC: {mexc_status}</div>', 
                   unsafe_allow_html=True)
        
        if not mexc_api or not mexc_secret:
            st.error("âš ï¸ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ MEXC API ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­Ø±Ù…Ø§Ù†Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯:")
            st.code("""
            MEXC_API_KEY = Ú©Ù„ÛŒØ¯_Ø§ÛŒ_Ù¾ÛŒ_Ø¢ÛŒ_Ø´Ù…Ø§
            MEXC_SECRET_KEY = Ú©Ù„ÛŒØ¯_Ù…Ø­Ø±Ù…Ø§Ù†Ù‡_Ø´Ù…Ø§
            """)
            return
        
        # Trading interface
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("ğŸ“Š ÙØ±Ù… Ø³ÙØ§Ø±Ø´")
            
            symbol = st.selectbox("Ø¬ÙØª Ø§Ø±Ø²", ["BTC/USDT", "ETH/USDT", "BNB/USDT"])
            side = st.radio("Ù†ÙˆØ¹ Ø³ÙØ§Ø±Ø´", ["Ø®Ø±ÛŒØ¯", "ÙØ±ÙˆØ´"])
            amount = st.number_input("Ù…Ù‚Ø¯Ø§Ø±", min_value=0.0001, step=0.0001, format="%.4f")
            price = st.number_input("Ù‚ÛŒÙ…Øª (Ø¯Ù„Ø§Ø±)", min_value=0.01, step=0.01)
            
            if st.button("ğŸš€ Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ", type="primary"):
                st.success(f"âœ… Ø³ÙØ§Ø±Ø´ Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ Ø«Ø¨Øª Ø´Ø¯: {side} {amount} {symbol} Ø¨Ù‡ Ù‚ÛŒÙ…Øª ${price}")
                st.balloons()
        
        with col2:
            st.subheader("ğŸ“‹ Ø³ÙØ§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±")
            
            # Sample orders data
            orders_data = pd.DataFrame({
                'Ø²Ù…Ø§Ù†': ['12:15:30', '12:10:15', '12:05:42'],
                'Ø¬ÙØª Ø§Ø±Ø²': ['BTC/USDT', 'ETH/USDT', 'BTC/USDT'],
                'Ù†ÙˆØ¹': ['Ø®Ø±ÛŒØ¯', 'ÙØ±ÙˆØ´', 'Ø®Ø±ÛŒØ¯'],
                'Ù…Ù‚Ø¯Ø§Ø±': [0.001, 0.05, 0.0005],
                'Ù‚ÛŒÙ…Øª': [118500, 3640, 118200],
                'ÙˆØ¶Ø¹ÛŒØª': ['âœ… Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡', 'âœ… Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡', 'â³ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±']
            })
            
            st.dataframe(orders_data, hide_index=True)
    
    def render_intelligence_panel(self):
        """Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ"""
        st.header("ğŸ§  Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("ğŸ“Š Ø¢Ù…Ø§Ø± ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ")
            
            # Intelligence metrics
            progress = st.progress(0.735)
            st.write("Ø³Ø·Ø­ Ù‡ÙˆØ´ ÙØ¹Ù„ÛŒ: 73.5%")
            
            metrics_data = {
                'Ú©Ù„ Ú†Ø±Ø®Ù‡â€ŒÙ‡Ø§': 847,
                'Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡': 156,
                'Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡': 23,
                'Ù†Ø±Ø® Ù…ÙˆÙÙ‚ÛŒØª': '78.4%'
            }
            
            for metric, value in metrics_data.items():
                st.metric(metric, value)
        
        with col2:
            st.subheader("ğŸ¯ ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯")
            
            recommendations = [
                "ğŸ“ˆ Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ† Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ Ø¯Ø§Ø±Ø¯ - Ù…ÙˆÙ‚Ø¹ÛŒØª Ø·ÙˆÙ„Ø§Ù†ÛŒ Ù…Ù†Ø§Ø³Ø¨",
                "âš ï¸ Ø§ØªØ±ÛŒÙˆÙ… Ø¨Ù‡ Ù…Ù‚Ø§ÙˆÙ…Øª 3700 Ø¯Ù„Ø§Ø± Ù†Ø²Ø¯ÛŒÚ© Ù…ÛŒâ€ŒØ´ÙˆØ¯", 
                "ğŸ” Ù†ÙˆØ³Ø§Ù†Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØªÙ‡ - Ø§Ù†Ø¯Ø§Ø²Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ú©Ø§Ù‡Ø´ Ø¯Ù‡ÛŒØ¯",
                "ğŸ’¡ ÙØ±ØµØª Ø¢Ø±Ø¨ÛŒØªØ±Ø§Ú˜ Ø¨ÛŒÙ† ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯"
            ]
            
            for rec in recommendations:
                st.info(rec)
    
    def render_system_info(self):
        """Ù†Ù…Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø³ÛŒØ³ØªÙ…"""
        with st.sidebar:
            st.header("âš™ï¸ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø³ÛŒØ³ØªÙ…")
            
            # Connection status summary
            connection_status = st.session_state.get('connection_status', 'poor')
            if connection_status == 'excellent':
                st.success("ğŸŸ¢ Ù‡Ù…Ù‡ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ ÙØ¹Ø§Ù„")
            elif connection_status == 'good':
                st.info("ğŸ”µ Ø§Ú©Ø«Ø± Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ ÙØ¹Ø§Ù„")
            elif connection_status == 'fair':
                st.warning("ğŸŸ¡ Ø¨Ø±Ø®ÛŒ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ Ø¯Ú†Ø§Ø± Ù…Ø´Ú©Ù„")
            else:
                st.error("ğŸ”´ Ú†Ù†Ø¯ÛŒÙ† Ø³ÛŒØ³ØªÙ… Ø¢ÙÙ„Ø§ÛŒÙ†")
                st.info("ğŸ’¡ ØµÙØ­Ù‡ Ø±Ø§ ØªØ§Ø²Ù‡ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø§ØªØµØ§Ù„ Ø´Ø¨Ú©Ù‡ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯")
            
            # System status
            services = self.check_system_status()
            
            st.subheader("ğŸ”§ ÙˆØ¶Ø¹ÛŒØª Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§")
            for service, info in services.items():
                status = info.get('status', 'unknown')
                emoji = "ğŸŸ¢" if status == 'online' else "ğŸ”´" if status == 'offline' else "ğŸŸ¡"
                status_fa = 'Ø¢Ù†Ù„Ø§ÛŒÙ†' if status == 'online' else 'Ø¢ÙÙ„Ø§ÛŒÙ†' if status == 'offline' else 'Ù†Ø§Ù…Ø´Ø®Øµ'
                error_info = ""
                if status == 'offline' and 'error' in info:
                    error_info = f" ({info['error']})"
                service_name = service.replace('_', ' ').replace('keep alive', 'Ù†Ú¯Ù‡Ø¯Ø§Ø±Ù†Ø¯Ù‡').replace('production', 'ØªÙˆÙ„ÛŒØ¯').replace('telegram bot', 'Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù…').replace('intelligence', 'Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ')
                st.write(f"{emoji} {service_name}: {status_fa}{error_info}")
            
            st.subheader("ğŸ“Š Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø³ÛŒØ³ØªÙ…")
            current_time = datetime.now().strftime("%H:%M:%S")
            st.write(f"ğŸ•’ Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: {current_time}")
            st.write("ğŸ”„ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±: 30 Ø«Ø§Ù†ÛŒÙ‡")
            st.write("ğŸ›¡ï¸ ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯ Ø§ØªØµØ§Ù„: ÙØ¹Ø§Ù„")
            
            # Network status indicator
            st.subheader("ğŸŒ ÙˆØ¶Ø¹ÛŒØª Ø´Ø¨Ú©Ù‡")
            try:
                # Quick connectivity test
                test_response = requests.get('http://localhost:8080/ping', timeout=1)
                st.write("ğŸŸ¢ Ø´Ø¨Ú©Ù‡ Ù…Ø­Ù„ÛŒ: Ø¹Ø§Ø¯ÛŒ")
            except:
                st.write("ğŸ”´ Ø´Ø¨Ú©Ù‡ Ù…Ø­Ù„ÛŒ: Ù…Ø´Ú©Ù„ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯")
            
            st.subheader("ğŸ”‘ ÙˆØ¶Ø¹ÛŒØª API")
            mexc_api = os.getenv('MEXC_API_KEY')
            mexc_secret = os.getenv('MEXC_SECRET_KEY')
            binance_api = os.getenv('BINANCE_API_KEY')
            binance_secret = os.getenv('BINANCE_SECRET_KEY')
            
            st.write(f"ğŸ”‘ MEXC API: {'âœ…' if mexc_api else 'âŒ'}")
            st.write(f"ğŸ” MEXC Secret: {'âœ…' if mexc_secret else 'âŒ'}")
            st.write(f"ğŸ”‘ Binance API: {'âœ…' if binance_api else 'âŒ'}")
            st.write(f"ğŸ” Binance Secret: {'âœ…' if binance_secret else 'âŒ'}")
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("ğŸ”„ ØªØ§Ø²Ù‡â€ŒØ³Ø§Ø²ÛŒ", use_container_width=True):
                    st.session_state.last_refresh = 0  # Force refresh
                    st.rerun()
            
            with col2:
                if st.button("ğŸš€ Ø±ÛŒØ³Øª", use_container_width=True):
                    # Clear session state
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()

def main():
    """ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ"""
    dashboard = TradingDashboard()
    
    # Render dashboard components
    dashboard.render_header()
    dashboard.render_system_info()
    
    # Main content tabs
    tab1, tab2, tab3 = st.tabs(["ğŸ“ˆ Ø¨Ø§Ø²Ø§Ø±", "ğŸ’° Ù…Ø¹Ø§Ù…Ù„Ø§Øª", "ğŸ§  Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ"])
    
    with tab1:
        dashboard.render_market_data()
        
        # Price chart
        st.subheader("ğŸ“Š Ù†Ù…ÙˆØ¯Ø§Ø± Ù‚ÛŒÙ…Øª")
        
        # Generate sample chart data
        dates = pd.date_range(start='2025-01-01', end='2025-01-24', freq='D')
        prices = [118000 + i*50 + (i%3)*200 for i in range(len(dates))]
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=dates, y=prices, mode='lines', name='Ù‚ÛŒÙ…Øª BTC'))
        fig.update_layout(title='Ø±ÙˆÙ†Ø¯ Ù‚ÛŒÙ…Øª Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†', xaxis_title='ØªØ§Ø±ÛŒØ®', yaxis_title='Ù‚ÛŒÙ…Øª (Ø¯Ù„Ø§Ø±)')
        st.plotly_chart(fig, use_container_width=True)
    
    with tab2:
        dashboard.render_trading_panel()
    
    with tab3:
        dashboard.render_intelligence_panel()
        
        # AI Learning chart
        st.subheader("ğŸ“ˆ Ù¾ÛŒØ´Ø±ÙØª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ")
        
        learning_data = pd.DataFrame({
            'Ú†Ø±Ø®Ù‡': range(1, 11),
            'Ù‡ÙˆØ´': [45.2, 47.8, 52.1, 55.6, 58.3, 59.1, 60.2, 60.8, 61.1, 73.5]
        })
        
        fig = px.line(learning_data, x='Ú†Ø±Ø®Ù‡', y='Ù‡ÙˆØ´', 
                     title='Ø±Ø´Ø¯ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø± Ø·ÙˆÙ„ Ø²Ù…Ø§Ù†')
        st.plotly_chart(fig, use_container_width=True)
    
    # Footer
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: #666;'>
        ğŸ¤– ULTRA_PLUS_BOT Ù†Ø³Ø®Ù‡ 2.0 | Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø¨Ø§ Streamlit | 
        ğŸ”„ Ù¾Ø§ÛŒØ¯Ø§Ø± Ùˆ Ø§Ù†Ø¹Ø·Ø§Ùâ€ŒÙ¾Ø°ÛŒØ± | ğŸš€ Ø¢Ù…Ø§Ø¯Ù‡ ØªÙˆÙ„ÛŒØ¯
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()